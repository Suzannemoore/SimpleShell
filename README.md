# SimpleShell
This project consists of designing a C program to serve as a shell interface that accepts user commands and then executes each command in a separate process. A shell interface gives the user a prompt, after which the next command is entered.

This shell begins by setting a run flag to 1 (true) and prompting the user to enter a command. The first thing the program does when a loop begins is getting the current working directory for use with cd. Then it prints the prompt. We now wait for a command to be entered.

A global variable i is initalized, this will keep track of the number of total arguments for each command. The function fgets() is used to collect user input into a buffer (cmd). We then tokenize this buffer with a delimiter that gets rid of all spaces and extraneous chars like \n. After this a loop moves to the end of the buffer and places a null terminating zero there to indicate the end of the array.

Now we can check if no command is entered. If this is the case, (size_t len of first argument equals 1), the program will continue and loop again.

There is now a check for exit input, if exit is typed in as the first (or only) argument of a command, the flag is set to false and the program terminates. 

If cd is typed in as the first argument, we enter an if statement that sets the cd flag to true and then if a path is specified at argument 2 we go to this path through chdir(). If there is only one argument, travel to root. Otherwise, it is an invalid directory and we will print and error and continue.

If fg is entered as the first argument, and the number of background processes (check using counter for this) is not 0, we get the pid of the process and put it inside the background processes array. Then we call waitpid() on this pid to bring the process to the foreground and run. Upon waitpid() finishing, we can decrement the counter at this point.
Next, we check if pipe symbol is used. To do this we first initalize a pipe flag to false, create a loop indexing counter, temporary variable to store index of pipe, and two pointer arrays for storing the commands before and after pipe symbol. We now loop through the token array (cmd input tokenized). We set the pipe flag to true, set the temp variable to the index of pipe. Now we use loop logic to get the first and second parts of the commands into our new pointer arrays. This is what we will use to pass into execvp() to execute pipe.

If the > symbol is entered, we simply set a flag for redirect to true.
Now, we can execute fork() and set a pid_t pid equal to fork(). Now, we just have an if statement checking to make sure fork() didn't fail. We have an if statment to see if pid = 0. If it does, we are in the child and this is where most of the shell functionality will be written. Otherwie, if pid is not 0 and not less than 1, we are in the parent. The background processes will be executed here. 
In the parent process, we have an if else statement. If the background flag is true, that means the user typed in a command in which a process is going to run in the background (& symbol was seen). In this case, the parent process won't be waiting for the child to complete. In order to keep track of our background processes, we will set the last index of the background processes array to the local pid. We increment the count since we now have a new background process. Finally, we print the pid information for the user. Now, if the background flag is false, we call waitpid() on local pid and allow the child process to finish while the parent waits. 

In the child process, we have a flag for if pipe is used in a command. If the flag is true, we peform the operations for pipe between two programs. The first thing we do is declare a pipe fd. Index 0 of this fd will be used as the read end of the pipe, while index 1 of the fd is the read end. We now call pipe(pfd) (the variable pfd is the name of our pipe fd). Now we need to fork() and if it is successful, we begin by closing stdout and assigning stdout to copy the write end of fd pipe. We now close write end of pipe. Finally, we call execvp() on our arguments that we parsed in the pipe if statment above. We only pass in the first set of arguments prior to pipe symbol. We now call fork() again, and if it is successful, we do the same thing as before with our last fork(). Except this time, we close stdin, and call dup(pfd[0]) to assign stdin to copy the fd pipe for read. Now close, read end of pipe, and execvp() on our second set of args that came after pipe symbol. So, pipe works by opening a write end of a pipe and sending stdout of the first set of args, then receiving stdin at the read end of pipe. 

In the child process, we also have a flag for if > is typed in. The first thing we do for this case is declare two file pointers that will be used with cat and >. The function fopen() is used to open the files specifed at the command line and assigned to the file pointers from before. One read file, one for write. If the read file doesn't exist, we print an error message. The write file is created automatically if it doesn't exist. Next, we use dup2() to copy fp1 contents to stdin, and fp2 contents to stdout. We call fclose() to close the file pointers. Finally, we pass in arguments to execvp(). This can be hardcoded since no parsing needed to be done for the array that will be used to execute commands here. We pass in the path of the command (token[0]), the file to be written to token[3], and the file that will be read token[1]. The last argument is a 0 to indicate the end of the array. Now, execvp() is called on these arguments and the process is run. 

If neither of these flags (| or >) are true, then we simply execute a process in the foreground with execvp() passing in the whole tokenized command line array we have. If execvp() fails, it means something went wrong (usually it is just an invalid command), so we print an error messsage that will execute in this case. This sits right below execvp(), but this will never execute unless execvp() fails.
